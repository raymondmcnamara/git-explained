<div>
<h1>Chapter 2: Intro to Git</h1>
<h2>Version Control</h2>
<p>Version control is a system that helps track changes to files or code over time, allowing multiple people to collaborate on a project efficiently. It records changes, stores different versions of the files, and makes it possible to revert to earlier versions or compare differences between versions.</p>
<h2>Git</h2>
<p>Git is a distributed version control system used to track changes in source code during software development. It allows multiple developers to work on the same codebase at the same time without interfering with each other’s work.</p>
<h2>Init</h2>
<p>The git init command initializes a new Git repository in the current directory. It creates a hidden .git folder that stores all the metadata, configurations, and version history for the project. After running this command, the directory becomes a Git repository, allowing you to start tracking changes, committing files, and using other Git features.</p>
<h2>Commit Object</h2>
<p>A commit object in Git represents a snapshot of your project at a specific point in time. It stores a reference to the project’s file structure (a tree), metadata like the author and committer, a commit message, and a reference to one or more parent commits. Each commit is uniquely identified by a SHA-1 hash, and together these commits form the history of your repository.</p>
<h2>Working Directory</h2>
<p>The Git working directory is the local folder where you see and edit your project files. It reflects the current state of the project as checked out from the repository. When you make changes to files in this directory, Git can detect them as modified, and you can choose to stage and commit those changes to the repository.<p>
<h2>Add Command</h2>
<p>The git add command in Git is used to stage changes in your working directory for the next commit. When you modify, create, or delete files, Git tracks those changes but doesn’t include them in a commit until you explicitly add them. Running git add filename tells Git to include that file’s current state in the staging area, meaning it’s ready to be committed. You can also use git add . to stage all changes in the current directory and its subdirectories. This command is a key step in Git’s workflow, separating the process of making changes from committing them, allowing you to review and control exactly what gets committed.</p>
<h2>Index/Staging Area</h2>
<p>In Git, the index (also known as the staging area) is an intermediate space where changes are gathered before they are committed to the repository. When you modify files in your working directory and use git add, those changes are added to the index. This lets you control which changes will be included in the next commit. The index acts as a snapshot of your intended next commit, allowing you to stage some changes while leaving others out. Once you're satisfied, running git commit saves the staged changes from the index into the repository's history.</p>
<h2>Object Database</p>
<p>The Git object database is where Git stores all your project data—files, directories, and commits—as compressed objects. Each object (a blob, tree, commit, or tag) is identified by a unique hash, allowing Git to track changes efficiently and avoid duplicating data. This database lives in the .git/objects directory of your repository.</p>
</div>
<h2>Flow of Changes</h2>
<div>When you change a file in Git, the update first lives in the working directory—your local filesystem. Running git add stages the change by copying a snapshot of the file into the index (also called the staging area). Then, when you run git commit, Git saves the staged snapshot to the object database in the .git directory, creating a new commit that points to that snapshot. Finally, git push sends the new commit(s) from your local repository to a remote repository, such as GitHub.</div>

p109 (do file states next)